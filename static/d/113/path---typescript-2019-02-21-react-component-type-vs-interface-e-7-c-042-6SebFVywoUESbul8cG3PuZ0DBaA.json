{"data":{"site":{"pathPrefix":"","siteMetadata":{"title":"Joonsung Um's blog","author":"JoonsungUm","siteUrl":"","locale":"ko","comment":{"disqusShortName":"","utterances":"JoonsungUm/JoonsungUm.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"0679acbc-f2f1-53c6-9561-736ea4070cab","excerpt":"타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. 리액트 스펙문서에서도 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이었다. 최근에 React component에서 사용되는 props와 state의 타입을 기술할 때는 type을 사용하여 작성하는 방법을 고려해보라는 글들을 보게되었고 그에 관해 알아본 내용들을 적어 보았다. 와  에 관한 공식 문서들 TypeScript Language…","html":"<p>타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. 리액트 스펙문서에서도 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이었다. 최근에 React component에서 사용되는 props와 state의 타입을 기술할 때는 type을 사용하여 작성하는 방법을 고려해보라는 글들을 보게되었고 그에 관해 알아본 내용들을 적어 보았다.</p>\n<h2 id=\"code-classlanguage-textinterfacecode와-code-classlanguage-texttypecode에-관한-공식-문서들\"><a href=\"#code-classlanguage-textinterfacecode%EC%99%80-code-classlanguage-texttypecode%EC%97%90-%EA%B4%80%ED%95%9C-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C%EB%93%A4\" aria-label=\"code classlanguage textinterfacecode와 code classlanguage texttypecode에 관한 공식 문서들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">interface</code>와 <code class=\"language-text\">type</code>에 관한 공식 문서들</h2>\n<h3 id=\"typescript-language-specification-의-type-aliases-section\"><a href=\"#typescript-language-specification-%EC%9D%98-type-aliases-section\" aria-label=\"typescript language specification 의 type aliases section permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#310-type-aliases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript Language Specification 의 Type Aliases section</a></h3>\n<blockquote>\n<p>Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases.</p>\n</blockquote>\n<p><code class=\"language-text\">interface</code> 타입과 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 많은 점이 비슷하지만, <code class=\"language-text\">type</code> 별칭 보다 더 많은 가능성이 있기에 <code class=\"language-text\">interface</code>를 사용하는 것을 일반적으로 권장합니다.</p>\n<blockquote>\n<ul>\n<li>An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.</li>\n<li>An interface can have multiple merged declarations, but a type alias for an object type literal cannot.</li>\n</ul>\n</blockquote>\n<ul>\n<li>인터페이스는 <code class=\"language-text\">extends</code> 와 <code class=\"language-text\">implements</code> 구문에 사용될 수 있지만, 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 그럴 수 없습니다.</li>\n<li>인터페이스는 여러 번 선언해도 병합될 수 있지만, 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 그럴 수 없습니다.</li>\n</ul>\n<h3 id=\"typescript-handbook의\"><a href=\"#typescript-handbook%EC%9D%98\" aria-label=\"typescript handbook의 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Typescript Handbook의 ]</h3>\n<h2 id=\"이-포스트-작성-시점의-최신-typescript-33의-type과-interface의-동작\"><a href=\"#%EC%9D%B4-%ED%8F%AC%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1-%EC%8B%9C%EC%A0%90%EC%9D%98-%EC%B5%9C%EC%8B%A0-typescript-33%EC%9D%98-type%EA%B3%BC-interface%EC%9D%98-%EB%8F%99%EC%9E%91\" aria-label=\"이 포스트 작성 시점의 최신 typescript 33의 type과 interface의 동작 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이 포스트 작성 시점의 최신 Typescript 3.3의 type과 interface의 동작</h2>\n<p><img src=\"../../assets/typescript/2019-02-21-react-component-type-vs-interface.png\" alt=\"Karol Majewski&#x27;s types vs. interfaces in Typescript\"></p>","timeToRead":2,"frontmatter":{"title":"Typescript와 React를 사용할 때, props와 state의 타입을 작성하는 방법에 대한 고민","date":"2019-02-21T16:44:03.000Z"}}},"pageContext":{"slug":"/typescript/2019-02-21-react-component-type-vs-interface/","previous":null,"next":{"fields":{"slug":"/introduce/2019-02-13-introducing-this-blog/"},"frontmatter":{"title":"Introducing This Blog","category":"introduce"}}}}