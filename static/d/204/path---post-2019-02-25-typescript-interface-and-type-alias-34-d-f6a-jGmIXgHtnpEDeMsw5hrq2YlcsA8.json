{"data":{"site":{"pathPrefix":"","siteMetadata":{"title":"Joonsung Um's blog","author":"JoonsungUm","siteUrl":"","locale":"ko","comment":{"disqusShortName":"","utterances":"JoonsungUm/JoonsungUm.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"0fc94355-72ed-538b-873f-7536879868f2","excerpt":"타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. TypeScript 공식 문서에서 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이다. 최근 타입스크립트는 빠른 주기로 릴리즈가 되고 있기 때문에 문서가 업데이트되지 않아 현재의 동작을 제대로 설명하지 못하고 있다는 내용의 글을 보았는데 정말 그런지 살펴보았다. 이후의 내용들은 2019년 2월 현재 시점의 TypeScript 3.…","html":"<p>타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. TypeScript 공식 문서에서 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이다. 최근 타입스크립트는 빠른 주기로 릴리즈가 되고 있기 때문에 문서가 업데이트되지 않아 현재의 동작을 제대로 설명하지 못하고 있다는 내용의 글을 보았는데 정말 그런지 살펴보았다. 이후의 내용들은 2019년 2월 현재 시점의 TypeScript 3.3에서 확인한 내용이다.</p>\n<h2 id=\"interface와-type에-관한-공식-문서들\"><a href=\"#interface%EC%99%80-type%EC%97%90-%EA%B4%80%ED%95%9C-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C%EB%93%A4\" aria-label=\"interface와 type에 관한 공식 문서들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interface와 Type에 관한 공식 문서들</h2>\n<p>TypeScript 자체는 빠르게 릴리즈되고 있는데 문서화의 속도가 따라오지 못하는 것으로 보인다. Typescript 3.0 부터 등장한 <code class=\"language-text\">unknown</code> type의 경우에도 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#typescript-30\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What’s new in TypeScript · Microsoft/TypeScript Wiki · GitHub</a>나 <a href=\"https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript | Announcing TypeScript 3.0</a>에서 확인 할 수 있지만 TypeScript를 새롭게 배우고자 하는 사람들이 주로 정보를 확인하는 스펙 문서나 TypeScript Handbook에서는 관련 내용을 찾아보기 힘들다. 기존 사용자라 할지라도 새로운 버전이 릴리즈 될 때마다 변경 사항에 관한 문서를 꼼꼼하게 챙겨보지 않으면 최신 버전의 TypeScript의 변경점에 대해 알지 못할 수도 있다. 문서와 코드 사이의 거리가 벌어지고 있다는 점은 좋지 않은 신호이지만, 다르게 생각한다면 현재의 TypeScript 프로젝트는 문서화에 많은 도움이 필요하다는 것이고, 개인 개발자에게는 TypeScript 레포지토리에 Contribute 할 수 있는 좋은 기회일지도 모른다.</p>\n<h3 id=\"typescript-language-specification-의-type-aliases-section\"><a href=\"#typescript-language-specification-%EC%9D%98-type-aliases-section\" aria-label=\"typescript language specification 의 type aliases section permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/Microsoft/TypeScript/blob/f30e8a284ac479a96ac660c94084ce5170543cc4/doc/spec.md#3.10\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript Language Specification 의 Type Aliases section</a></h3>\n<p>문서 맨 위에 Version 1.8, January, 2016으로 버전과 날짜가 명시되어 있고 이 후의 커밋 기록은 오타를 수정한 것 정도이다.</p>\n<blockquote>\n<p>Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases.</p>\n<ul>\n<li>An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.</li>\n<li>An interface can have multiple merged declarations, but a type alias for an object type literal cannot.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><code class=\"language-text\">interface</code> 타입과 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 많은 점이 비슷하지만, <code class=\"language-text\">type</code> 별칭 보다 더 많은 것을 할 수 있기에 <code class=\"language-text\">interface</code>를 사용하는 것을 일반적으로 권장합니다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">interface</code>는 <code class=\"language-text\">extends</code> 와 <code class=\"language-text\">implements</code> 구문에 사용될 수 있지만, 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 그럴 수 없습니다.</p>\n<ul>\n<li><em>현재 시점에서는 변경되었으며 <code class=\"language-text\">type</code> 정의 안에 <code class=\"language-text\">union</code>이 사용된 경우를 제외하고 <code class=\"language-text\">extends</code>, <code class=\"language-text\">implements</code> 모두 <code class=\"language-text\">interface</code>와 같이 동작한다.</em></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">interface</code>는 여러 번 선언해도 병합(declaration merging)될 수 있지만, 객체 자체에 대한 <code class=\"language-text\">type</code> 별칭은 그럴 수 없습니다.</p>\n<ul>\n<li><em>현재 시점에서도 마찬가지로 <code class=\"language-text\">type</code> 별칭은 선언 병합(declaration merging)을 할 수 없다.</em></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"typescript-handbook의-type-aliases-section\"><a href=\"#typescript-handbook%EC%9D%98-type-aliases-section\" aria-label=\"typescript handbook의 type aliases section permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/Microsoft/TypeScript-Handbook/blob/f728031b7ab1cf54934c86dc41dbf8774369f866/pages/Advanced%20Types.md#type-aliases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript Handbook의 Type Aliases section</a></h3>\n<p>추가되거나 변경 된 내용이 반영되고는 있지만 여전히 최신 TypeScript의 내용을 잘 따라가고 있지 못하다.</p>\n<blockquote>\n<h4 id=\"interfaces-vs-type-aliases\"><a href=\"#interfaces-vs-type-aliases\" aria-label=\"interfaces vs type aliases permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/Microsoft/TypeScript-Handbook/blob/f728031b7ab1cf54934c86dc41dbf8774369f866/pages/Advanced%20Types.md#interfaces-vs-type-aliases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Interfaces vs. Type Aliases</a></h4>\n<p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>\n<p>One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> Alias <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Interface</span> <span class=\"token punctuation\">{</span>\n  num<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">aliased</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">:</span> Alias<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Alias\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">interfaced</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">:</span> Interface<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Interface</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types). Because an ideal property of software is being open to extension, you should always use an interface over a type alias if possible.</p>\n<p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p>\n</blockquote>\n<blockquote>\n<p>앞서 언급했듯이, <code class=\"language-text\">type</code> 별칭은 <code class=\"language-text\">interface</code>와 같은 역할을 할 수 있지만 약간의 차이점이 있습니다.</p>\n<p>한 가지 차이점은 <code class=\"language-text\">interface</code>가 어디에서나 사용되는 새 이름을 만든다는 것입니다. <code class=\"language-text\">type</code> 별칭으로는 새 이름을 만들 수 없습니다. 예를 들어 오류 메시지에서는 별칭 이름을 사용하지 않습니다. 아래 코드를 편집기에서 <code class=\"language-text\">interfaced</code> 위로 마우스를 가져가면 <code class=\"language-text\">interface</code>가 표시되는 것을 볼 수 있지만, <code class=\"language-text\">aliased</code>는 객체 자체의 타입으로 표시되는 것을 볼 수 있습니다.</p>\n<ul>\n<li><em>현재 시점에서는 위 코드의 <code class=\"language-text\">interfaced</code>와 <code class=\"language-text\">aliased</code> 모두 새로운 이름이 생성된다.</em></li>\n</ul>\n<p>두 번째로 중요한 차이점은 <code class=\"language-text\">type</code> 별칭은 <code class=\"language-text\">extends</code>/<code class=\"language-text\">implements</code>에 사용 될 수 없고, 이를 사용 할 수도 없다는 점입니다. 소프트웨어의 이상적인 특성은 확장할 수 있도록 열려있는 것이기 때문에 가능한 경우 <code class=\"language-text\">type</code> 별칭 대신 <code class=\"language-text\">interface</code>를 사용해야합니다.</p>\n<ul>\n<li><em>현재 시점에서는 변경되었으며 <code class=\"language-text\">type</code> 정의 안에 <code class=\"language-text\">union</code>이 사용된 경우를 제외하고 <code class=\"language-text\">extends</code>, <code class=\"language-text\">implements</code> 모두 <code class=\"language-text\">interface</code>와 같이 동작한다.</em></li>\n</ul>\n<p>반대로, <code class=\"language-text\">interface</code>로는 모양을 표현할 수 없는 경우와 <code class=\"language-text\">union</code> 혹은 <code class=\"language-text\">tuple</code> 타입이 필요한 경우, 보통 <code class=\"language-text\">type</code> 별칭을 사용합니다.</p>\n</blockquote>\n<h2 id=\"참고한-자료들\"><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%9C-%EC%9E%90%EB%A3%8C%EB%93%A4\" aria-label=\"참고한 자료들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고한 자료들</h2>\n<p>주로 구글에서 <code class=\"language-text\">typescript interface vs type</code>로 검색한 내용들이다.</p>\n<h3 id=\"interface-vs-type-alias-in-typescript-27--martin-hochel--medium\"><a href=\"#interface-vs-type-alias-in-typescript-27--martin-hochel--medium\" aria-label=\"interface vs type alias in typescript 27  martin hochel  medium permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Interface vs Type alias in TypeScript 2.7 – Martin Hochel – Medium</a></h3>\n<p>2018년 3월에 쓰여졌으며 TypeScript 2.7에서의 동작을 설명하고 있고 현재도 유효하다.</p>\n<blockquote>\n<p>So what’s the difference between type alias and interface again 🤖?</p>\n<ol>\n<li>you cannot use implements on an class with type alias if you use union operator within your type definition</li>\n<li>you cannot use extends on an interface with type alias if you use union operator within your type definition</li>\n<li>declaration merging doesn’t work with type alias</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>그렇다면 유형 별칭과 인터페이스의 차이점은 무엇입니까?</p>\n<ol>\n<li>타입 정의 내에서 union 연산자(<code class=\"language-text\">|</code>)를 사용하면 <code class=\"language-text\">class</code>에서 <code class=\"language-text\">type</code> 별칭을 사용하여 <code class=\"language-text\">implements</code> 할 수 없습니다.</li>\n<li>타입 정의 내에서 union 연산자(<code class=\"language-text\">|</code>)를 사용한다면 <code class=\"language-text\">interface</code>에서 <code class=\"language-text\">type</code> 별칭을 사용하여 <code class=\"language-text\">extends</code>를 사용할 수 없습니다.</li>\n<li>선언 병합은 <code class=\"language-text\">type</code> 별칭에서 동작하지 않습니다.</li>\n</ol>\n</blockquote>\n<h3 id=\"typescript-interfaces-vs-types---stack-overflow\"><a href=\"#typescript-interfaces-vs-types---stack-overflow\" aria-label=\"typescript interfaces vs types   stack overflow permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Typescript: Interfaces vs Types - Stack Overflow</a></h3>\n<p><a href=\"https://stackoverflow.com/users/4500152/jabacchetta\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">User jabacchetta - Stack Overflow</a>의 답글로 2019년 1월에 쓰여졌으며 예제 코드를 중심으로 잘 설명되어 있다.</p>\n<h3 id=\"typescript-interfaces-vs-types---stack-overflow-1\"><a href=\"#typescript-interfaces-vs-types---stack-overflow-1\" aria-label=\"typescript interfaces vs types   stack overflow 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/54101543#54101543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Typescript: Interfaces vs Types - Stack Overflow</a></h3>\n<p><a href=\"https://stackoverflow.com/users/10325032/karol-majewski\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">User Karol Majewski - Stack Overflow</a>의 답글에 첨부된 이미지로 TypeScript 3.2의 동작에 관해서 작성된 이미지다.</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 103.29861111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAADTElEQVQ4y4VViW7bSgz0/39ckTZp0jzHia37Wt2yVqtjOqTsIEXx0IUHS60kakgO6cO6rhiGQSH2tm1/7V+xrvs+TRPG64h5mT/fd87hsCwLPM/DhZjnWZ38C7KyIse7f8ZkJ5zO7zh+vKHve3G4omlbVFWNLM+RE4UxyLJMPyDrD4YbHW6AmQxeh1e9n885TuNJ7YNzM6I4hR9G8INIbb2+2V1/xWgdxpEhks2Vu7MrwjbBg3nENgGXxsejecYybTgIi8KUZFYgzciwEHY5qrqhsx6WTuZ5gXzY8VnZNxKP+xQ/qidgAYI+wnP9qrbmUEJNklSRphnCKEbbdQyRzzAl8swdMwFGba4Fjs1Rww8HOmx+qX2Qr8ZJTicJHRuyLBSeH5Jlq+EOV6uh3jGMM8ahhBsSFoUM2wgv1XEPWb6asgBxnKAoCi2G2GVZaRG+rruUqBxMfYshj/Q8UoYvO0PJoTDKCEMnkk/JpTEVw+5RVg3PKhjuPQs0MYfWLbBDC9sVWJlPvwvxVNHhfHMYkZGEGDOHEXHxAq2yOL7w/Hj6wJlnkgJLQduJUusz5M0bFgckXYz3+qS2hlzXtepQQq5q2Y1eC1pqtCxL3b+ubCzws911uLkGcEZTcZjYLn4YI2BR3s8eWWbKTs487sIwoH2/Pns+8qyiDmN8yx/YghtaU6COA4xMxUFkIEzqplXt1U3DzumYu0ptQ3bCuuY9UYQQWOcNGWXzq3nVQri+w0wfy3arckLtRdSe5FIguQzIJmD3eH6guhT7Oo67DvlLhwxP9U/VZM3iZMaHtLm2nlaZGky4S2hyLZW961I0Gqe5pkXaz9kFUZviqXzR1jt3Ab6zyut0K0qS8IU41sEgBTAcDlFEhkGg5yHZSaFkLeuiYSZjiofmh56tLNhWlEJ2ZyhMCh7khLJiX7edzLiRYVrtlIGzz8qQIOw0o6eTJk8xUypRl+C/6g2ru+lQcxbuOTtffM2jTBfHoSBCdjdMn1gxdjWuZfwp7MfqeR8Ooh2pasdhIAOyYWWttX/NwT/Bd+eWQs72eWg5bPuPfR4uU4FrX1IinYpXRC55/X9nglWdCnSC31pehu9hnRv+N+w6/Orw32vD3dOG7XOQ/AZPcEx8Au6QGAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Karol Majewski's types vs. interfaces in Typescript\"\n        title=\"\"\n        src=\"/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png\"\n        srcset=\"/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/707e9/types-vs-interface.png 148w,\n/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/649e0/types-vs-interface.png 295w,\n/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png 590w,\n/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/b3fef/types-vs-interface.png 885w,\n/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png 1152w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<h2 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<h3 id=\"interface의-declaration-merging이-가장-큰-차이이다\"><a href=\"#interface%EC%9D%98-declaration-merging%EC%9D%B4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%B0%A8%EC%9D%B4%EC%9D%B4%EB%8B%A4\" aria-label=\"interface의 declaration merging이 가장 큰 차이이다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interface의 Declaration Merging이 가장 큰 차이이다</h3>\n<ul>\n<li><code class=\"language-text\">interface</code>는 같은 이름으로 여러번 선언을 해도 컴파일 시점에서 합쳐지기 때문에 확장성이 좋다. 따라서 일반적인 경우에는 <code class=\"language-text\">interface</code>를 사용하고 <code class=\"language-text\">union</code>, <code class=\"language-text\">tuple</code> 등이 필요한 경우에만 <code class=\"language-text\">type</code> 별칭을 사용하라는 TypeScript Handbook의 내용은 현재에도 유효하다.</li>\n<li><code class=\"language-text\">declaration merging</code>으로 확장 가능하기 때문에, 외부에 노출해야하는 public API에 사용되는 타입은 항상 <code class=\"language-text\">interface</code>를 사용하여 작성해야 한다.</li>\n<li><code class=\"language-text\">type</code> 별칭으로 작성된 타입은 조금 더 제한적이기 때문에 private API 같이 외부에 노출 할 필요가 없는 경우에 사용하는 것이 좋다.</li>\n</ul>\n<h3 id=\"react-component의-props와-state의-타입을-기술하려면-어떤-것이-좋을까\"><a href=\"#react-component%EC%9D%98-props%EC%99%80-state%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%84-%EA%B8%B0%EC%88%A0%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"react component의 props와 state의 타입을 기술하려면 어떤 것이 좋을까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Component의 Props와 State의 타입을 기술하려면 어떤 것이 좋을까?</h3>\n<p><code class=\"language-text\">interface</code>와 <code class=\"language-text\">type alias</code>에 대해 알아보기 시작한 이유이다.</p>\n<ul>\n<li>일반적인 경우에는 <code class=\"language-text\">interface</code>를 사용해도 무리가 없다.</li>\n<li>React component를 사용하는데 <code class=\"language-text\">declaration merging</code>이나 <code class=\"language-text\">implements</code>는 필요 없다.</li>\n<li><code class=\"language-text\">interface</code>는 union이 사용되었다면 <code class=\"language-text\">extends</code> 할 수 없기 때문에 해당 경우에는 <code class=\"language-text\">type</code> 별칭을 사용해서 타입을 기술해야 한다.</li>\n</ul>","timeToRead":7,"frontmatter":{"title":"TypeScript에서 type을 기술하는 두 가지 방법, Interface와 Type Alias","date":"2019-02-25T09:24:32.000Z"}}},"pageContext":{"slug":"/post/2019-02-25-typescript-interface-and-type-alias/","previous":{"fields":{"slug":"/post/2019-02-13-introducing-this-blog/"},"frontmatter":{"title":"Introducing This Blog","category":"introduce"}},"next":{"fields":{"slug":"/post/2019-03-05-react-component-interface-vs-type-alias/"},"frontmatter":{"title":"Typescript와 React를 사용할 때, props와 state의 타입을 작성하는 방법에 대한 고민","category":"typescript, react"}}}}