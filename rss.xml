<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Joonsung Um's blog]]></title><description><![CDATA[Blog posted about programming]]></description><link>http://github.com/dylang/node-rss</link><generator>RSS for Node</generator><lastBuildDate>Mon, 25 Feb 2019 07:35:30 GMT</lastBuildDate><item><title><![CDATA[Typescript와 React를 사용할 때, props와 state의 타입을 작성하는 방법에 대한 고민]]></title><description><![CDATA[타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. Typescript 공식 문서에서도 특별한 상황이 아니라면 interface…]]></description><link>/post/2019-03-05-react-component-interface-vs-type-alias/</link><guid isPermaLink="false">/post/2019-03-05-react-component-interface-vs-type-alias/</guid><pubDate>Tue, 05 Mar 2019 16:44:03 GMT</pubDate><content:encoded>&lt;p&gt;타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민없이 interface를 사용하고 있었다. Typescript 공식 문서에서도 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이었다. 최근에 React component에서 사용되는 props와 state의 타입을 기술할 때는 type을 사용하여 작성하는 방법을 고려해보라는 글들을 보게되었고 그에 관해 알아본 내용들을 적어 보았다.&lt;/p&gt;
&lt;h2 id=&quot;interface와-type에-관한-공식-문서들&quot;&gt;&lt;a href=&quot;#interface%EC%99%80-type%EC%97%90-%EA%B4%80%ED%95%9C-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C%EB%93%A4&quot; aria-label=&quot;interface와 type에 관한 공식 문서들 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interface와 Type에 관한 공식 문서들&lt;/h2&gt;
&lt;h3 id=&quot;typescript-language-specification-의-type-aliases-section&quot;&gt;&lt;a href=&quot;#typescript-language-specification-%EC%9D%98-type-aliases-section&quot; aria-label=&quot;typescript language specification 의 type aliases section permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#310-type-aliases&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript Language Specification 의 Type Aliases section&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;li&gt;An interface can have multiple merged declarations, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt; 타입과 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 많은 점이 비슷하지만, &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭 보다 더 많은 것을 할 수 있기에 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용하는 것을 일반적으로 권장합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스는 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 구문에 사용될 수 있지만, 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 그럴 수 없습니다.&lt;/li&gt;
&lt;li&gt;인터페이스는 여러 번 선언해도 병합될 수 있지만, 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 그럴 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;typescript-handbook의-advanced-types-section&quot;&gt;&lt;a href=&quot;#typescript-handbook%EC%9D%98-advanced-types-section&quot; aria-label=&quot;typescript handbook의 advanced types section permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Typescript Handbook의 Advanced Types section&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;interfaces-vs-type-aliases&quot;&gt;&lt;a href=&quot;#interfaces-vs-type-aliases&quot; aria-label=&quot;interfaces vs type aliases permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interfaces vs. Type Aliases&lt;/h4&gt;
&lt;p&gt;As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.&lt;/p&gt;
&lt;p&gt;One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-typescript line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; Alias &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; num&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Interface&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  num&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;aliased&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Alias&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Alias
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;interfaced&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Interface&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Interface&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types). Because an ideal property of software is being open to extension, you should always use an interface over a type alias if possible.&lt;/p&gt;
&lt;p&gt;On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;typescript의-공식-문서가-틀렸다&quot;&gt;&lt;a href=&quot;#typescript%EC%9D%98-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C%EA%B0%80-%ED%8B%80%EB%A0%B8%EB%8B%A4&quot; aria-label=&quot;typescript의 공식 문서가 틀렸다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Typescript의 공식 문서가 틀렸다?&lt;/h2&gt;
&lt;h3 id=&quot;이-포스트-작성-시점2019년-2월의-typescript-3의-type과-interface의-동작&quot;&gt;&lt;a href=&quot;#%EC%9D%B4-%ED%8F%AC%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1-%EC%8B%9C%EC%A0%902019%EB%85%84-2%EC%9B%94%EC%9D%98-typescript-3%EC%9D%98-type%EA%B3%BC-interface%EC%9D%98-%EB%8F%99%EC%9E%91&quot; aria-label=&quot;이 포스트 작성 시점2019년 2월의 typescript 3의 type과 interface의 동작 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이 포스트 작성 시점(2019년 2월)의 Typescript 3의 type과 interface의 동작&lt;/h3&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 103.29861111111111%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAADTElEQVQ4y4VViW7bSgz0/39ckTZp0jzHia37Wt2yVqtjOqTsIEXx0IUHS60kakgO6cO6rhiGQSH2tm1/7V+xrvs+TRPG64h5mT/fd87hsCwLPM/DhZjnWZ38C7KyIse7f8ZkJ5zO7zh+vKHve3G4omlbVFWNLM+RE4UxyLJMPyDrD4YbHW6AmQxeh1e9n885TuNJ7YNzM6I4hR9G8INIbb2+2V1/xWgdxpEhks2Vu7MrwjbBg3nENgGXxsejecYybTgIi8KUZFYgzciwEHY5qrqhsx6WTuZ5gXzY8VnZNxKP+xQ/qidgAYI+wnP9qrbmUEJNklSRphnCKEbbdQyRzzAl8swdMwFGba4Fjs1Rww8HOmx+qX2Qr8ZJTicJHRuyLBSeH5Jlq+EOV6uh3jGMM8ahhBsSFoUM2wgv1XEPWb6asgBxnKAoCi2G2GVZaRG+rruUqBxMfYshj/Q8UoYvO0PJoTDKCEMnkk/JpTEVw+5RVg3PKhjuPQs0MYfWLbBDC9sVWJlPvwvxVNHhfHMYkZGEGDOHEXHxAq2yOL7w/Hj6wJlnkgJLQduJUusz5M0bFgckXYz3+qS2hlzXtepQQq5q2Y1eC1pqtCxL3b+ubCzws911uLkGcEZTcZjYLn4YI2BR3s8eWWbKTs487sIwoH2/Pns+8qyiDmN8yx/YghtaU6COA4xMxUFkIEzqplXt1U3DzumYu0ptQ3bCuuY9UYQQWOcNGWXzq3nVQri+w0wfy3arckLtRdSe5FIguQzIJmD3eH6guhT7Oo67DvlLhwxP9U/VZM3iZMaHtLm2nlaZGky4S2hyLZW961I0Gqe5pkXaz9kFUZviqXzR1jt3Ab6zyut0K0qS8IU41sEgBTAcDlFEhkGg5yHZSaFkLeuiYSZjiofmh56tLNhWlEJ2ZyhMCh7khLJiX7edzLiRYVrtlIGzz8qQIOw0o6eTJk8xUypRl+C/6g2ru+lQcxbuOTtffM2jTBfHoSBCdjdMn1gxdjWuZfwp7MfqeR8Ooh2pasdhIAOyYWWttX/NwT/Bd+eWQs72eWg5bPuPfR4uU4FrX1IinYpXRC55/X9nglWdCnSC31pehu9hnRv+N+w6/Orw32vD3dOG7XOQ/AZPcEx8Au6QGAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Karol Majewski&apos;s types vs. interfaces in Typescript&quot;
        title=&quot;&quot;
        src=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png&quot;
        srcset=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/707e9/types-vs-interface.png 148w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/649e0/types-vs-interface.png 295w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png 590w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/b3fef/types-vs-interface.png 885w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png 1152w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TypeScript에서 Type을 기술하는 두 가지 방법, Interface와 Type Alias]]></title><description><![CDATA[타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민 없이 interface를 사용하고 있었다. TypeScript 공식 문서에서 특별한 상황이 아니라면 interface…]]></description><link>/post/2019-02-25-typescript-interface-and-type-alias/</link><guid isPermaLink="false">/post/2019-02-25-typescript-interface-and-type-alias/</guid><pubDate>Mon, 25 Feb 2019 09:24:32 GMT</pubDate><content:encoded>&lt;p&gt;타입스크립트를 사용하기 시작한 뒤로 type을 기술할 때, 일반적인 상황에서는 특별한 고민 없이 interface를 사용하고 있었다. TypeScript 공식 문서에서 특별한 상황이 아니라면 interface의 사용을 권장하고 있기 때문이다. 최근 타입스크립트는 빠른 주기로 릴리즈가 되고 있기 때문에 문서가 업데이트되지 않아 현재의 동작을 제대로 설명하지 못하고 있다는 내용의 글을 보았는데 정말 그런지 살펴보았다. 이후의 내용은 2019년 2월 현재 시점의 TypeScript 3.3에서 확인한 내용이다.&lt;/p&gt;
&lt;h2 id=&quot;interface와-type에-관한-공식-문서들&quot;&gt;&lt;a href=&quot;#interface%EC%99%80-type%EC%97%90-%EA%B4%80%ED%95%9C-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C%EB%93%A4&quot; aria-label=&quot;interface와 type에 관한 공식 문서들 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interface와 Type에 관한 공식 문서들&lt;/h2&gt;
&lt;p&gt;TypeScript 자체는 빠르게 릴리즈되고 있는데 문서화의 속도가 따라오지 못하는 것으로 보인다. Typescript 3.0부터 등장한 &lt;code class=&quot;language-text&quot;&gt;unknown&lt;/code&gt; type의 경우에도 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/What&amp;#x27;s-new-in-TypeScript#typescript-30&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;What’s new in TypeScript · Microsoft/TypeScript Wiki · GitHub&lt;/a&gt; 나 &lt;a href=&quot;https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript | Announcing TypeScript 3.0&lt;/a&gt;에서 확인할 수 있지만 TypeScript를 새롭게 배우고자 하는 사람들이 주로 정보를 확인하는 스펙 문서나 TypeScript Handbook에서는 관련 내용을 찾아보기 힘들다. 기존 사용자라 할지라도 새로운 버전이 릴리즈 될 때마다 변경 사항에 관한 문서를 꼼꼼하게 챙겨보지 않으면 최신 버전의 TypeScript의 변경 점에 대해 알지 못할 수도 있다. 문서와 코드 사이의 거리가 벌어지고 있다는 점은 좋지 않은 신호이지만, 다르게 생각한다면 현재의 TypeScript 프로젝트는 문서화에 많은 도움이 필요하다는 것이고, 개인 개발자에게는 TypeScript 레포지토리에 Contribute 할 좋은 기회일지도 모른다.&lt;/p&gt;
&lt;h3 id=&quot;typescript-language-specification-의-type-aliases-section&quot;&gt;&lt;a href=&quot;#typescript-language-specification-%EC%9D%98-type-aliases-section&quot; aria-label=&quot;typescript language specification 의 type aliases section permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/f30e8a284ac479a96ac660c94084ce5170543cc4/doc/spec.md#3.10&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript Language Specification 의 Type Aliases section&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;문서 맨 위에 Version 1.8, January, 2016으로 버전과 날짜가 명시되어 있고 이후의 커밋 기록은 오타를 수정한 것 정도이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;li&gt;An interface can have multiple merged declarations, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt; 타입과 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 많은 점이 비슷하지만, &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭보다 더 많은 것을 할 수 있기에 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용하는 것을 일반적으로 권장합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 구문에 사용될 수 있지만, 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 그럴 수 없습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;현재 시점에서는 변경되었으며 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 정의 안에 &lt;code class=&quot;language-text&quot;&gt;union&lt;/code&gt;이 사용된 경우를 제외하고 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 모두 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;와 같이 동작한다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;는 여러 번 선언해도 병합(declaration merging)될 수 있지만, 객체 자체에 대한 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 그럴 수 없습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;현재 시점에서도 마찬가지로 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 선언 병합(declaration merging)을 할 수 없다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;typescript-handbook의-type-aliases-section&quot;&gt;&lt;a href=&quot;#typescript-handbook%EC%9D%98-type-aliases-section&quot; aria-label=&quot;typescript handbook의 type aliases section permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Handbook/blob/f728031b7ab1cf54934c86dc41dbf8774369f866/pages/Advanced%20Types.md#type-aliases&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript Handbook의 Type Aliases section&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;추가되거나 변경된 내용이 반영되고는 있지만, 여전히 최신 TypeScript의 내용을 잘 따라가고 있지 못하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;interfaces-vs-type-aliases&quot;&gt;&lt;a href=&quot;#interfaces-vs-type-aliases&quot; aria-label=&quot;interfaces vs type aliases permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Handbook/blob/f728031b7ab1cf54934c86dc41dbf8774369f866/pages/Advanced%20Types.md#interfaces-vs-type-aliases&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Interfaces vs. Type Aliases&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.&lt;/p&gt;
&lt;p&gt;One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-typescript line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; Alias &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; num&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Interface&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  num&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;aliased&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Alias&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Alias
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;interfaced&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Interface&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Interface&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types). Because an ideal property of software is being open to extension, you should always use an interface over a type alias if possible.&lt;/p&gt;
&lt;p&gt;On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;앞서 언급했듯이, &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;와 같은 역할을 할 수 있지만 약간의 차이점이 있습니다.&lt;/p&gt;
&lt;p&gt;한 가지 차이점은 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;가 어디에서나 사용되는 새 이름을 만든다는 것입니다. &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭으로는 새 이름을 만들 수 없습니다. 예를 들어 오류 메시지에서는 별칭 이름을 사용하지 않습니다. 아래 코드를 편집기에서 &lt;code class=&quot;language-text&quot;&gt;interfaced&lt;/code&gt; 위로 마우스를 가져가면 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;가 표시되는 것을 볼 수 있지만, &lt;code class=&quot;language-text&quot;&gt;aliased&lt;/code&gt;는 객체 자체의 타입으로 표시되는 것을 볼 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;현재 시점에서는 위 코드의 &lt;code class=&quot;language-text&quot;&gt;interfaced&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;aliased&lt;/code&gt; 모두 새로운 이름이 생성된다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 번째로 중요한 차이점은 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭은 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;/&lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt;에 사용될 수 없고, 이를 사용 할 수도 없다는 점입니다. 소프트웨어의 이상적인 특성은 확장할 수 있도록 열려있는 것이기 때문에 가능한 경우 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭 대신 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;현재 시점에서는 변경되었으며 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 정의 안에 &lt;code class=&quot;language-text&quot;&gt;union&lt;/code&gt;이 사용된 경우를 제외하고 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 모두 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;와 같이 동작한다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반대로, &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;로는 모양을 표현할 수 없는 경우와 &lt;code class=&quot;language-text&quot;&gt;union&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;tuple&lt;/code&gt; 타입이 필요한 경우, 보통 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭을 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;참고한-자료들&quot;&gt;&lt;a href=&quot;#%EC%B0%B8%EA%B3%A0%ED%95%9C-%EC%9E%90%EB%A3%8C%EB%93%A4&quot; aria-label=&quot;참고한 자료들 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;참고한 자료들&lt;/h2&gt;
&lt;p&gt;주로 구글에서 &lt;code class=&quot;language-text&quot;&gt;typescript interface vs type&lt;/code&gt;으로 검색한 내용이다.&lt;/p&gt;
&lt;h3 id=&quot;interface-vs-type-alias-in-typescript-27--martin-hochel--medium&quot;&gt;&lt;a href=&quot;#interface-vs-type-alias-in-typescript-27--martin-hochel--medium&quot; aria-label=&quot;interface vs type alias in typescript 27  martin hochel  medium permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Interface vs Type alias in TypeScript 2.7 – Martin Hochel – Medium&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;2018년 3월에 쓰였으며 TypeScript 2.7에서의 동작을 설명하고 있고 현재도 유효하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So what’s the difference between type alias and interface again 🤖?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;you cannot use implements on an class with type alias if you use union operator within your type definition&lt;/li&gt;
&lt;li&gt;you cannot use extends on an interface with type alias if you use union operator within your type definition&lt;/li&gt;
&lt;li&gt;declaration merging doesn’t work with type alias&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;그렇다면 유형 별칭과 인터페이스의 차이점은 무엇입니까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;타입 정의 내에서 union 연산자(&lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt;)를 사용하면 &lt;code class=&quot;language-text&quot;&gt;class&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭을 사용하여 &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 할 수 없습니다.&lt;/li&gt;
&lt;li&gt;타입 정의 내에서 union 연산자(&lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt;)를 사용한다면 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭을 사용하여 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;를 사용할 수 없습니다.&lt;/li&gt;
&lt;li&gt;선언 병합은 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭에서 동작하지 않습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;typescript-interfaces-vs-types---stack-overflow&quot;&gt;&lt;a href=&quot;#typescript-interfaces-vs-types---stack-overflow&quot; aria-label=&quot;typescript interfaces vs types   stack overflow permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Typescript: Interfaces vs Types - Stack Overflow&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/4500152/jabacchetta&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;User jabacchetta - Stack Overflow&lt;/a&gt;의 답글로 2019년 1월에 쓰였으며 예제 코드를 중심으로 잘 설명되어 있다.&lt;/p&gt;
&lt;h3 id=&quot;typescript-interfaces-vs-types---stack-overflow-1&quot;&gt;&lt;a href=&quot;#typescript-interfaces-vs-types---stack-overflow-1&quot; aria-label=&quot;typescript interfaces vs types   stack overflow 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/54101543#54101543&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Typescript: Interfaces vs Types - Stack Overflow&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/10325032/karol-majewski&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;User Karol Majewski - Stack Overflow&lt;/a&gt;의 답글에 첨부된 이미지로 TypeScript 3.2의 동작에 관해서 작성된 이미지다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 103.29861111111111%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAADTElEQVQ4y4VViW7bSgz0/39ckTZp0jzHia37Wt2yVqtjOqTsIEXx0IUHS60kakgO6cO6rhiGQSH2tm1/7V+xrvs+TRPG64h5mT/fd87hsCwLPM/DhZjnWZ38C7KyIse7f8ZkJ5zO7zh+vKHve3G4omlbVFWNLM+RE4UxyLJMPyDrD4YbHW6AmQxeh1e9n885TuNJ7YNzM6I4hR9G8INIbb2+2V1/xWgdxpEhks2Vu7MrwjbBg3nENgGXxsejecYybTgIi8KUZFYgzciwEHY5qrqhsx6WTuZ5gXzY8VnZNxKP+xQ/qidgAYI+wnP9qrbmUEJNklSRphnCKEbbdQyRzzAl8swdMwFGba4Fjs1Rww8HOmx+qX2Qr8ZJTicJHRuyLBSeH5Jlq+EOV6uh3jGMM8ahhBsSFoUM2wgv1XEPWb6asgBxnKAoCi2G2GVZaRG+rruUqBxMfYshj/Q8UoYvO0PJoTDKCEMnkk/JpTEVw+5RVg3PKhjuPQs0MYfWLbBDC9sVWJlPvwvxVNHhfHMYkZGEGDOHEXHxAq2yOL7w/Hj6wJlnkgJLQduJUusz5M0bFgckXYz3+qS2hlzXtepQQq5q2Y1eC1pqtCxL3b+ubCzws911uLkGcEZTcZjYLn4YI2BR3s8eWWbKTs487sIwoH2/Pns+8qyiDmN8yx/YghtaU6COA4xMxUFkIEzqplXt1U3DzumYu0ptQ3bCuuY9UYQQWOcNGWXzq3nVQri+w0wfy3arckLtRdSe5FIguQzIJmD3eH6guhT7Oo67DvlLhwxP9U/VZM3iZMaHtLm2nlaZGky4S2hyLZW961I0Gqe5pkXaz9kFUZviqXzR1jt3Ab6zyut0K0qS8IU41sEgBTAcDlFEhkGg5yHZSaFkLeuiYSZjiofmh56tLNhWlEJ2ZyhMCh7khLJiX7edzLiRYVrtlIGzz8qQIOw0o6eTJk8xUypRl+C/6g2ru+lQcxbuOTtffM2jTBfHoSBCdjdMn1gxdjWuZfwp7MfqeR8Ooh2pasdhIAOyYWWttX/NwT/Bd+eWQs72eWg5bPuPfR4uU4FrX1IinYpXRC55/X9nglWdCnSC31pehu9hnRv+N+w6/Orw32vD3dOG7XOQ/AZPcEx8Au6QGAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Karol Majewski&apos;s types vs. interfaces in Typescript&quot;
        title=&quot;&quot;
        src=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png&quot;
        srcset=&quot;/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/707e9/types-vs-interface.png 148w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/649e0/types-vs-interface.png 295w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/40fad/types-vs-interface.png 590w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/b3fef/types-vs-interface.png 885w,
/static/5e3ff7197c3a7bc3ca3ab68fc6dffce2/c92ff/types-vs-interface.png 1152w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;정리&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정리&lt;/h2&gt;
&lt;h3 id=&quot;interface의-declaration-merging이-가장-큰-차이이다&quot;&gt;&lt;a href=&quot;#interface%EC%9D%98-declaration-merging%EC%9D%B4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%B0%A8%EC%9D%B4%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;interface의 declaration merging이 가장 큰 차이이다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interface의 Declaration Merging이 가장 큰 차이이다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;는 같은 이름으로 여러 번 선언을 해도 컴파일 시점에서 합쳐지기 때문에 확장성이 좋다. 따라서 일반적으로는 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용하고 &lt;code class=&quot;language-text&quot;&gt;union&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;tuple&lt;/code&gt; 등이 필요한 경우에만 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭을 사용하라는 TypeScript Handbook의 내용은 현재에도 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;declaration merging&lt;/code&gt;으로 확장할 수 있기 때문에, 외부에 노출해야 하는 public API에 사용되는 타입은 항상 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용하여 작성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭으로 작성된 타입은 조금 더 제한적이기 때문에 private API같이 외부에 노출할 필요가 없는 경우에 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;react-component의-props와-state의-타입을-기술하려면-어떤-것이-좋을까&quot;&gt;&lt;a href=&quot;#react-component%EC%9D%98-props%EC%99%80-state%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%84-%EA%B8%B0%EC%88%A0%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;react component의 props와 state의 타입을 기술하려면 어떤 것이 좋을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React Component의 Props와 State의 타입을 기술하려면 어떤 것이 좋을까?&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;type alias&lt;/code&gt;에 대해 알아보기 시작한 이유이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로는 &lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;를 사용해도 무리가 없다.&lt;/li&gt;
&lt;li&gt;React component를 사용하는데 &lt;code class=&quot;language-text&quot;&gt;declaration merging&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt;는 필요 없다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt;는 union이 사용되었다면 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt; 할 수 없기 때문에 해당 경우에는 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 별칭을 사용해서 타입을 기술해야 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Introducing This Blog]]></title><description><![CDATA[블로그를 만드는 과정에서 느낀 점을 적어보았다. 서비스형 블로그 vs…]]></description><link>/post/2019-02-13-introducing-this-blog/</link><guid isPermaLink="false">/post/2019-02-13-introducing-this-blog/</guid><pubDate>Wed, 13 Feb 2019 20:44:03 GMT</pubDate><content:encoded>&lt;p&gt;블로그를 만드는 과정에서 느낀 점을 적어보았다.&lt;/p&gt;
&lt;h2 id=&quot;서비스형-블로그-vs-설치형-블로그&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%B9%84%EC%8A%A4%ED%98%95-%EB%B8%94%EB%A1%9C%EA%B7%B8-vs-%EC%84%A4%EC%B9%98%ED%98%95-%EB%B8%94%EB%A1%9C%EA%B7%B8&quot; aria-label=&quot;서비스형 블로그 vs 설치형 블로그 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서비스형 블로그 vs 설치형 블로그&lt;/h2&gt;
&lt;p&gt;얼마 전 블로그를 만들어야겠다고 생각했을 때, 가장 중요하게 생각했던 것은 얼마나 포터블하냐는 것이었다. 언제든지 올린 데이터 모두를 편리한 포맷으로 내려받을 수 있도록 특정 플랫폼에 얽매이고 싶지 않았고 가능하다면 마크다운을 사용하고 싶었다.&lt;/p&gt;
&lt;p&gt;예전에 싸이월드가 망하면서 즐거웠던 시절의 사진을 몽창 잃어버린 기억이 있기 때문에 퍼블릭 export API가 잘 만들어져 있는 서비스가 아니면 사용하고 싶지 않았고 국내 서비스 중 스팀잇이나 브런치 등을 들어본 적은 있지만, export 환경이 잘 되어있는지는 왠지 알아보고 싶지도 않았다. 😖&lt;/p&gt;
&lt;p&gt;미디움을 비롯한 해외 서비스형 블로그 플랫폼들도 비슷한 이유로 호감이 가지 않았으며, 결국 셀프호스팅 쪽으로 마음이 기울기 시작했다.&lt;/p&gt;
&lt;h2 id=&quot;서비스형-notion-vs-coda&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%B9%84%EC%8A%A4%ED%98%95-notion-vs-coda&quot; aria-label=&quot;서비스형 notion vs coda permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서비스형: Notion vs Coda&lt;/h2&gt;
&lt;p&gt;설치형으로 마음이 기울기 시작하는 와중에 최근까지도 후보에 놓고 고민했던 것이 &lt;a href=&quot;https://www.notion.so/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.&lt;/a&gt;이다.&lt;/p&gt;
&lt;p&gt;요새 많은 스타트업에서 사용하고 있고 내부에서만 사용하는 것이 아니라 공개적인 채용 공고 같은 것도 Notion으로 작성된 문서가 종종 보인다. 회사에서 (회삿돈으로) 사용하기에는 아주 좋은 제품이지만 곧 백수가 될 예정이기 때문에 이전, 이후에 나올 모든 조건보다 최상위에 속하는 제약조건인 &lt;em&gt;유료 (개인 한 달 4딸라)&lt;/em&gt; 라는 것이 걸렸다. 사용해보니 무료 quota 1000블록으로는 뭘 할 수가 없는 수준이었다.&lt;/p&gt;
&lt;p&gt;구글에서 &lt;code class=&quot;language-text&quot;&gt;notion vs&lt;/code&gt;를 치면 자동완성으로 제시되는 &lt;a href=&quot;https://coda.io/welcome&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Coda. A doc as powerful as an app.&lt;/a&gt; 를 살펴보았다. 일단 마크다운이 아니었고 현재는 외부 공개용 문서를 작성하는 용도는 아니었다. 또한 코드 블록 하이라이팅이 지원되지 않는 상태였다. 탈락!&lt;/p&gt;
&lt;h2 id=&quot;설치형-github-pages--gatsbyjs-vs-netlify--gatsbyjs&quot;&gt;&lt;a href=&quot;#%EC%84%A4%EC%B9%98%ED%98%95-github-pages--gatsbyjs-vs-netlify--gatsbyjs&quot; aria-label=&quot;설치형 github pages  gatsbyjs vs netlify  gatsbyjs permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;설치형: Github Pages + GatsbyJS vs Netlify + GatsbyJS&lt;/h2&gt;
&lt;p&gt;정적 사이트 무료 호스팅으로는 이 두 가지 선택지가 눈에 들어왔다. 구글 클라우드는 애초에 고려대상이 아니었는데 그 이유는 내가 잘 쓰고 있던 &lt;a href=&quot;https://www.blog.google/products/gmail/inbox-signing-find-your-favorite-features-new-gmail/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Inbox 서비스를 종료한다는 소식&lt;/a&gt;이 들려와 매우 기분이 상해있었기 때문이다.&lt;/p&gt;
&lt;p&gt;Github Pages는 &lt;a href=&quot;https://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Jekyll • Simple, blog-aware, static sites | Transform your plain text into static websites and blogs&lt;/a&gt; 기반일 때부터 간단한 외주 의뢰에도 사용할 정도로 친숙하지만, 예전에 어떤 Gem을 사용하느냐에 따라 빌드가 잘 되지 않았던 기억과 Ruby에 그리 친숙하지 않다는 점 때문에 계속 Jekyll을 사용하고 싶지는 않았다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.netlify.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Netlify: All-in-one platform for automating modern web projects.&lt;/a&gt; 는 최근 몇 번 사용해보고 반할 정도로 좋은 서비스이기는 하나 &lt;a href=&quot;https://github.com/netlify/netlify-cms&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;GitHub - netlify/netlify-cms: A CMS for Static Site Generators&lt;/a&gt;의 속도가 너무 느렸고 커스터마이징이 힘들고 손이 많이 갔다. Netlify의 CMS를 사용하지 않고 커스텀 도메인을 사용할 예정도 없다고 가정하면 굳이 신생 기업이라 인스턴스가 미국 중심일(실제로 그런지는 모름.) Netlify를 사용할만한 이유는 없다. 결국 Github에 소스를 올리는 것은 필수이니 글로~발한 마이크로소프트 소속 Github의 리소스를 사용하는 것이 낫다고 생각되어 Github Pages에 호스팅하고 주어지는 기본 도메인을 사용하는 것으로 결론 내렸다.&lt;/p&gt;
&lt;p&gt;정적 사이트 프레임워크는 &lt;a href=&quot;https://www.gatsbyjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;GatsbyJS&lt;/a&gt;로 큰 고민 없이 정했는데 React + TypeScript(Optional) + GraphQL 이면 친해 두는 것이 여러모로 좋다고 판단되었기 때문이다. 🤥&lt;/p&gt;
&lt;h2 id=&quot;그러면-gatsbyjs의-템플릿은-어떤-것으로&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%9F%AC%EB%A9%B4-gatsbyjs%EC%9D%98-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9C%BC%EB%A1%9C&quot; aria-label=&quot;그러면 gatsbyjs의 템플릿은 어떤 것으로 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그러면 GatsbyJS의 템플릿은 어떤 것으로…?&lt;/h2&gt;
&lt;p&gt;이러한 고민의 시간이 약 2주간에 걸쳐 계속되었고 결국 블로그로 사용할 스택이 정리되었다. 짬짬이 살펴본 것이기는 하지만 하나하나 고르는 데에 꽤 많은 시간을 사용했다. 물론 중간에 구정이 걸친 것도 한몫했지만. 이제 템플릿만 정하면 되는데 이게 또 주화입마에 빠지는 게 아닌가 할 정도로 여러 생각이 머리를 어지럽혔다.&lt;/p&gt;
&lt;p&gt;맨땅에서 시작하려다 너무 귀찮아서 기본 starter들을 살펴보다가 &lt;a href=&quot;https://github.com/gaearon&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;gaearon (Dan Abramov) · GitHub&lt;/a&gt; 형님의 &lt;a href=&quot;https://github.com/gaearon/overreacted.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;GitHub - gaearon/overreacted.io: Personal blog by Dan Abramov.&lt;/a&gt; 템플릿을 보게 되어 거의 이쪽으로 기우는 순간, 페이스북에서 &lt;a href=&quot;https://jbee.io/etc/intro-new-blog/?fbclid=IwAR3qvrdZanRBjD9WjU6R1oUiWTyEfMXUuaQSzI7z-uWsN0JjQ8r10ekLCUA&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;블로그를 만들며 고려한 것들 (JBEE.io) | JBEE.io&lt;/a&gt; 이런 글을 보게 되었다.&lt;/p&gt;
&lt;p&gt;이 블로그를 작성하신 &lt;a href=&quot;https://github.com/JaeYeopHan&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;JaeYeopHan (Jbee) · GitHub&lt;/a&gt; 님은 깃허브에서도 팔로우 한 분으로 완벽한 타이밍에 먼저 고민하신 내용과 그 고민의 결과물을 공유해주셔서 비로소 블로그를 구성하는 고민을 덜고 내용을 작성하기 시작할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;다음 글은 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;GitHub - JaeYeopHan/gatsby-starter-bee: 🐝Full Package | Simple | Fresh UI | Blog Template :: Let’s start to blogging with gatsby-starter-bee!&lt;/a&gt; 레포지토리를 TypeScript로 변환하면서 공부한 것들을 적을 생각이며 React Hooks API, Functional &amp;#x26; Class component에 대한 내용이 주가 될 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Your name Thank you for reading my resume. If you want to contact me, Please send me an email.]]></description><link>/resume-en/</link><guid isPermaLink="false">/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;your-name&quot;&gt;&lt;a href=&quot;#your-name&quot; aria-label=&quot;your name permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Your name&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;em&gt;Thank you for reading my resume. If you want to contact me, Please send me an email.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>